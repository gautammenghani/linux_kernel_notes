## Intro
1. Interrupt is an event that alters normal flow of execution. (can be generated by h/w devices or CPU itself)
2. Categories
	a. Synchronous : generated by executing an instruction
		- usually named exceptions, handle conditions detected by the processor itself in the course of executing an instruction. Divide by zero or a system call are examples of exceptions.
	b. async: generated by external event 
		- eg: n/w card gnerates an interrupt to signal that a packet has arrived.	
	c. maskable: can be ignored, signaled via INT pin
	d. Non maskable: can't be ignored, signaled by NMI pin
	
## Exceptions
1. Two sources of exceptions:	
	a. processor detected - faults, traps, aborts
	b. programmed - int n

## Interrupt handling on x86 architecture
1. Interrupt descriptor table (IDT)  	
	- Maps interrupt or exception identifier (vector number) with a descriptor for the instructions that service the associated event. 	

## Interrupt handling on linux
1. Interrupt handling is done in three phases: critical, immediate and deferred 
	a. critical: run the generic interrupt handler that determines the interrupt number, the interrupt handler for this particular interrupt and the interrupt controller. Also, local CPU interrupts are disabled for this phase.
	b. Immediate: all of the device driver's handlers associated with this interrupt will be executed. After completion, local processor interrupts are enabled.
	c. deferred: interrupt context deferrable actions will be run. These are also sometimes known as "bottom half" of the interrupt (the upper half being the part of the interrupt handling that runs with interrupts disabled). At this point, interrupts are enabled on the local processor.

## Nested interrupts and exceptionsÂ¶
1. Nesting between exceptions and interrupts as per below rules
  - an exception (e.g. page fault, system call) can not preempt an interrupt; if that occurs it is considered a bug
  - an interrupt can preempt an exception
  - an interrupt can not preempt another interrupt (it used to be possible)

2. Interrupt context
Code that runs in interrupt context has the following properties:
  - it runs as a result of an IRQ (not of an exception)
  - there is no well defined process context associated
  - not allowed to trigger a context switch (no sleep, schedule, or user memory access)

## Deferrable actions
1. Deferrable actions are used to run callback functions at a later time. If deferrable actions scheduled from an interrupt handler, the associated callback function will run after the interrupt handler has completed.

2. Two categories
  - Those that run in interrupt context : to avoid doing too much work in the interrupt handler function
  - Those that run in process context

## Soft IRQs
1. Soft IRQs is the term used for the low-level mechanism that implements deferring work from interrupt handlers but that still runs in interrupt context.

## Misc
1. Tasklets
Tasklets are a dynamic type (not limited to a fixed number) of deferred work running in interrupt context.

2. Workqueue
Workqueues are a type of deferred work that runs in process context.
They are implemented on top of kernel threads. 
